#if COMPILING_VS

layout (location = 0) in vec3  in_vertex;
layout (location = 1) in vec3  in_normal;
layout (location = 2) in vec3  in_tangent;
layout (location = 3) in vec2  in_texcoord;
//layout (location = 4) in vec3 in_bitangent; // @todo make bitangents streamed not calculated in vertex
#if ANIMATED_BONES
layout (location = 5) in ivec4 in_bone_ids;
layout (location = 6) in vec4  in_weights;
#endif

out vec3 position;
out vec2 texcoord;
out mat3 TBN;

uniform mat4 mvp;
uniform mat4 model;

#if ANIMATED_BONES
layout(std140, binding=1) uniform BoneMatrices 
{
    mat4 bone_matrices[MAX_BONES];
};
#endif

void main() {
#if ANIMATED_BONES
    mat4 bone_transform = mat4(0.0);
    for(int i = 0 ; i < MAX_BONE_WEIGHTS; i++) {
        if(in_bone_ids[i] == -1) 
            continue;

        bone_transform += bone_matrices[in_bone_ids[i]] * in_weights[i];
    }

    vec4 vertex = bone_transform * vec4(in_vertex, 1.0);
#else
    vec4 vertex = vec4(in_vertex, 1.0);
#endif

    gl_Position = mvp * vertex;
	position = (model * vertex).xyz;
	texcoord = in_texcoord;

#if ANIMATED_BONES
    // Copied this so might be wrong or inefficient
    mat3 bone_normal_transform = transpose(inverse(mat3(bone_transform)));

	vec3 T = normalize(vec3(model * vec4(bone_normal_transform*in_tangent, 0.0)));
	vec3 N = normalize(vec3(model * vec4(bone_normal_transform*in_normal, 0.0)));
#else
    vec3 T = normalize(vec3(model * vec4(in_tangent, 0.0)));
	vec3 N = normalize(vec3(model * vec4(in_normal, 0.0)));
#endif

	// Re-orthogonalize T with respect to N
    // Didn't seem to have any benifit
	//T = normalize(T - dot(T, N) * N);
	vec3 B = cross(N, T);

	// Transpose of perpendicular matrix is inverse
	TBN = mat3(T, B, N);
}

#endif

#if COMPILING_FS

#define PBR 1

in vec3 position;
in vec2 texcoord;
in mat3 TBN;

layout (location = 0) out vec4 out_color;

#ifdef BLOOM
layout (location = 1) out vec4 out_bloom_color; 
#endif

layout(binding = 0) uniform sampler2D albedo_map;
layout(binding = 1) uniform sampler2D normal_map;
uniform vec3 albedo_mult;

#ifdef PBR
layout(binding = 2) uniform sampler2D metallic_map;
uniform float metal_mult;
layout(binding = 3) uniform sampler2D roughness_map;
uniform float roughness_mult;
layout(binding = 4) uniform sampler2D ao_map;
uniform float ao_mult;

#load lib/shadows.gl
#load lib/pbr.gl
#else
uniform float specular_int;
uniform float specular_exp;
#load lib/blinn.gl
#endif

uniform vec3 camera_position;
uniform vec3 sun_direction;
uniform vec3 sun_color;

void main() {
	// obtain TBN normal from normal map in range [0,1]
    vec3 normal = texture(normal_map, texcoord).rgb;
    //// transform normal vector to range [-1,1]
    normal = normalize(normal * 2.0 - 1.0); 
    //// Transform normal from tangent to world space
    normal = TBN * normal;
    vec3 albedo = albedo_mult*texture(albedo_map, texcoord).xyz;

// @debug, renders different layers of csm in colors
//#if SHADOWS
//    float frag_dist = abs((view * vec4(position, 1.0)).z);
//    int layer = CASCADE_NUM;
//    for (int i = 0; i < CASCADE_NUM; ++i)
//    {
//        if (frag_dist < shadow_cascade_distances[i])
//        {
//            layer = i;
//            break;
//        }
//    }
//        
//    const vec3 colors[] = {vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 1.0)};
//    float NdotL = dot(normal, -sun_direction);
//    out_color = vec4(vec3((1.0-0.8*shadowness(NdotL, position))*colors[layer]), 1.0);
//#else
//    out_color = vec4(1.0);
//#endif

#ifndef PBR
    // Treats albedo as diffuse texture
    vec3 hdr_color = albedo * calcDirectionalLight(position, normal, sun_direction, sun_color, camera_position, specular_int, specular_exp);
#endif

#ifdef PBR
    float roughness  = roughness_mult*texture(roughness_map, texcoord).r; 
    float metallic   = metal_mult    *texture(metallic_map, texcoord).r; 

    vec3 GI = texture(ao_map, texcoord).rgb;
    float ao = ao_mult*length(GI);

    vec3 hdr_color = brdfSchlickGGX(position, normal, albedo, metallic, roughness, -sun_direction, sun_color, camera_position, ao, texture(ao_map, texcoord).rgb);
#endif

    out_color = vec4(hdr_color, gl_FrontFacing ? 1.0 : 0.0);
}

#endif
