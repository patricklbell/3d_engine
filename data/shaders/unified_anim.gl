#if COMPILING_VS

layout (location = 0) in vec3 in_vertex;
layout (location = 1) in vec3  in_normal;
layout (location = 2) in vec3  in_tangent;
layout (location = 3) in vec2  in_texcoord;
//layout (location = 4) in vec3 in_bitangent; // @todo make bitangents streamed not calculated in vertex
layout (location = 5) in ivec4 in_bone_ids;
layout (location = 6) in vec4  in_weights;

out vec3 position;
out vec2 texcoord;
out mat3 TBN;

uniform mat4 mvp;
uniform mat4 model;

const int MAX_BONES = 100;
const int MAX_BONE_INFLUENCE = 100;
layout(std140, binding=1) uniform BoneMatrices 
{
    mat4 bone_matrices[MAX_BONES];
};

void main() {
    mat4 bone_transform = mat4(0.0);
    for(int i = 0 ; i < MAX_BONE_INFLUENCE ; i++) {
        if(in_bone_ids[i] == -1) 
            continue;

        bone_transform += bone_matrices[in_bone_ids[i]] * in_weights[i];
    }

    vec4 vertex = bone_transform * vec4(in_vertex, 1.0);

    gl_Position = mvp * vertex;
	position = (model * vertex).xyz;
	texcoord = in_texcoord;

    // Copied this so might be wrong or inefficient
    mat3 bone_normal_transform = transpose(inverse(mat3(bone_transform)));

	vec3 T = normalize(vec3(model * vec4(bone_normal_transform*in_tangent, 0.0)));
	//vec3 B = normalize(vec3(model * vec4(in_bitangent, 0.0)));
	vec3 N = normalize(vec3(model * vec4(bone_normal_transform*in_normal, 0.0)));
	// re-orthogonalize T with respect to N
	//T = normalize(T - dot(T, N) * N);
	// then retrieve perpendicular vector B with the cross product of T and N
	vec3 B = cross(N, T);
	// Transpose of perpendicular matrix is inverse
	TBN = mat3(T, B, N);
}

#endif

#if COMPILING_FS

#define PBR 1

in vec3 position;
in vec2 texcoord;
in mat3 TBN;

layout (location = 0) out vec4 out_color;

#ifdef BLOOM
layout (location = 1) out vec4 out_bloom_color; 
#endif

uniform sampler2D normal_map;
uniform sampler2D albedo_map;
uniform vec3 albedo_mult;


#ifdef PBR
uniform sampler2D ao_map;
uniform float ao_mult;
uniform sampler2D metallic_map;
uniform float metal_mult;
uniform sampler2D roughness_map;
uniform float roughness_mult;
#load lib/pbr.gl
#else
uniform float specular_int;
uniform float specular_exp;
#load lib/blinn.gl
#endif

#load lib/shadows.gl

uniform vec3      camera_position;
uniform vec3      sun_direction;
uniform vec3      sun_color;


void main() {
	// obtain TBN normal from normal map in range [0,1]
    vec3 normal = texture(normal_map, texcoord).rgb;
    //// transform normal vector to range [-1,1]
    normal = normalize(normal * 2.0 - 1.0); 
    //// Transform normal from tangent to world space
    normal = TBN * normal;
    vec3 albedo = albedo_mult*texture(albedo_map, texcoord).xyz;

    // @debug, renders different layers of csm in colors
    //float frag_dist = abs((view * vec4(position, 1.0)).z);
    //int layer = CASCADE_NUM;
    //for (int i = 0; i < CASCADE_NUM; ++i)
    //{
    //    if (frag_dist < shadow_cascade_distances[i])
    //    {
    //        layer = i;
    //        break;
    //    }
    //}
    //    
    //const vec3 colors[] = {vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(1.0, 1.0, 0.0), vec3(1.0,
    //        0.0, 1.0)};
    //float NdotL = dot(normal, -sun_direction);
    //out_color = vec4(vec3(shadowness(NdotL)*colors[layer]), 1.0);

#ifndef PBR
    // Treats albedo as diffuse texture
    vec3 hdr_color = albedo * calcDirectionalLight(position, normal, sun_direction, sun_color, camera_position, specular_int, specular_exp);
#endif

#ifdef PBR
    //vec3 l = normalize(position - camera_position);
    //vec3 r = reflect(l, normalize(normal));

    //vec3  reflect    = vec4(texture(skybox, r).rgb, 1.0);
    float roughness  = roughness_mult*texture(roughness_map, texcoord).r; 
    float metallic   = metal_mult    *texture(metallic_map, texcoord).r; 
    float ao         = ao_mult       *texture(ao_map, texcoord).r + 0.04;

    vec3 ambient = albedo * ao;
    vec3 hdr_color = ambient + brdfSchlickGGX(position, normal, albedo, metallic, roughness, -sun_direction, sun_color, camera_position);
#endif

    out_color = vec4(hdr_color, 1.0);

#ifdef BLOOM
    // If we are doing bloom write to second buffer
    float brightness = dot(hdr_color, 0.5*vec3(0.2126, 0.7152, 0.0722));
    if(brightness > 1.0)
        out_bloom_color = vec4(hdr_color, 1.0);
    else
        out_bloom_color = vec4(0.0, 0.0, 0.0, 1.0);
#endif
}

#endif
