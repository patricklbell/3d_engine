#if COMPILING_VS

layout (location = 0) in vec3 in_vertex;
layout (location = 3) in vec2 in_texcoord;

out VS_FS {
  vec3 position;
  vec2 texcoord;
  vec4 shadow_coord;
  vec3 vertex;
} vs_out;

uniform mat4 model;
uniform mat4 mvp;
uniform mat4 shadow_mvp;
uniform float time;

#define WAVE_SPEED 0.1f

vec3 gwaves(in vec3 v) {
    const int wn = 3;
    const vec2  d[wn] = {normalize(vec2(0.2, 0.4)), normalize(vec2(0.3, 0.2)), normalize(vec2(0.5, 0.1))};
    const float a[wn] = {0.02, 0.01, 0.01};
    const float q[wn] = {2.7, 1.3, 4.3};
    const float p[wn] = {1.7, 5.8, 15.9};
    const float w[wn] = {5.0, 20.1, 50.0};

    vec3 res = v;
    for(int i = 0; i < wn; i++){
        float c1 = dot(w[i]*d[i], v.xz) + p[i]*time*WAVE_SPEED;
        float c2 = q[i]*a[i];
        res.x += c2*d[i].x * v.x*cos(c1);
        res.z += c2*d[i].y * v.z*cos(c1);

        res.y += a[i]*sin(c1);
    }
    return res;
}

void main(){
    vec3 vertex = gwaves(in_vertex);
    vec4 v = vec4(vertex, 1.0);
    gl_Position = mvp * v;
    vs_out.position = (model * v).xyz;
    vs_out.shadow_coord = shadow_mvp * v;
    vs_out.vertex = vertex;
    vs_out.texcoord = in_texcoord;
}

#endif

// Essentially a tesselation shader, but as geometry shader, make into tesselation which has lod for performance
//#if COMPILING_GS
//
//#define WAVE_STRENGTH vec2(0.45,  0.45)
//#define WAVE_FREQ     vec2(14.0, 14.0)
//#define WAVE_FACTOR   vec2(1.0,  2.0)
//#define TIME_FACTOR   vec2(1.1,  2.0)
//
//#define DIVISIONS     10.0
//
//layout (triangles) in;
//// Note max vertices are unique vertices given by n*(n + 2)
//layout (triangle_strip, max_vertices = 120) out;
//
//in VS_GS
//{
//  vec2 texcoord;
//} vs_in[];
//
//out GS_FS
//{
//  vec3 position;
//  vec2 texcoord;
//  vec4 shadow_coord;
//  vec3 vertex;
//} gs_out;
//
//
//uniform float time;
//uniform mat4 mvp;
//uniform mat4 shadow_mvp;
//uniform mat4 model;
//
//// https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models
//void gwaves(inout vec3 v) {
//  const int n = 1;
//  const vec2  d[] = {vec2(0.2, 0.5)};
//  const float a[] = {0.3};
//  const float q[] = {1.0};
//  const float p[] = {1.0};
//  const float w[] = {6.0};
//  for(int i = 0; i < n; i++){
//    float c1 = dot(w[i]*d[i], v.xz) + p[i]*time*0.9;
//    float c2 = q[i]*a[i];
//    v.x += c2*d[i].x * v.x*cos(c1);
//    v.z += c2*d[i].y * v.z*cos(c1);
//
//    v.y += a[i]*sin(c1);
//  }
//}
//
//void main() {
//  vec3 leg2 = gl_in[1].gl_Position.xyz - gl_in[0].gl_Position.xyz;
//  vec3 leg1 = gl_in[1].gl_Position.xyz - gl_in[2].gl_Position.xyz;
//  vec3 leg3 = gl_in[2].gl_Position.xyz - gl_in[0].gl_Position.xyz;
//  vec3 origin;
//  if(dot(leg2, leg2) > dot(leg1, leg1)){
//    leg1 = leg3;
//    origin = gl_in[0].gl_Position.xyz;
//  } else {
//    leg2 = leg3;
//    leg2 *= -1.0;
//    origin = gl_in[2].gl_Position.xyz;
//  }
//  leg1 /= DIVISIONS;
//  leg2 /= DIVISIONS;
//
//
//  vec4 v;
//  for(float x = 0.0; x < DIVISIONS; x++){
//    for(float y = 0.0; y < DIVISIONS - x; y++){
//      gs_out.vertex = origin + y*leg1 + x*leg2;
//      gwaves(gs_out.vertex);
//      v = vec4(gs_out.vertex, 1.0);
//      gl_Position = mvp * v;
//      gs_out.position = (model * v).xyz;
//      gs_out.shadow_coord = shadow_mvp * v;
//      gs_out.texcoord = vec2(y/DIVISIONS, x/DIVISIONS);
//      EmitVertex();
//      gs_out.vertex = origin + y*leg1 + (x+1.0)*leg2;
//      gwaves(gs_out.vertex);
//      v = vec4(gs_out.vertex, 1.0);
//      gl_Position = mvp * v;
//      gs_out.position = (model * v).xyz;
//      gs_out.shadow_coord = shadow_mvp * v;
//      gs_out.texcoord = vec2(y/DIVISIONS, (x+1.0)/DIVISIONS);
//      EmitVertex();
//    }
//    gs_out.vertex = origin + (DIVISIONS - x)*leg1 + x*leg2;
//    gwaves(gs_out.vertex);
//    v = vec4(gs_out.vertex, 1.0);
//    gl_Position = mvp * v;
//    gs_out.position = (model * v).xyz;
//    gs_out.shadow_coord = shadow_mvp * v;
//    gs_out.texcoord = vec2((DIVISIONS-x)/DIVISIONS, x/DIVISIONS);
//    EmitVertex();
//    EndPrimitive();
//  }
//}  
//
//#endif

#if COMPILING_FS

#load lib/constants.gl

#define EDGE_SCALE      1.252

#define SPEED           0.5
#define BEER_LAW_FACTOR 5.0

in VS_FS
{
    vec3 position;
    vec2 texcoord;
    vec4 shadow_coord;
    vec3 vertex;
} vs_in;

layout (depth_any) out float gl_FragDepth;
layout (location = 0) out vec4 out_color;



uniform vec3 sun_direction;
uniform vec3 sun_color;
uniform vec3 camera_position;

uniform vec2 resolution;
layout (binding = 0) uniform sampler2D screen_map;
layout (binding = 1) uniform sampler2D depth_map;
layout (binding = 2) uniform sampler2D simplex_gradient;
layout (binding = 3) uniform sampler2D simplex_value;
layout (binding = 4) uniform sampler2D collider;

uniform vec4 shallow_color;
uniform vec4 deep_color;
uniform vec4 foam_color;

uniform float time;
#define WAVE_SPEED 0.1f

#load lib/shadows.gl
#load lib/pbr.gl

// Use pre generated noise from
// https://www.shadertoy.com/view/XdXBRH
float noise(vec2 v){
   return texture(simplex_value, v).r;
}
vec3 normalnoise(vec2 v){
   return texture(simplex_gradient, v).rgb;
}

vec3 dgwaves(in vec3 v) {
    const int wn = 3;
    const vec2  d[wn] = {normalize(vec2(0.2, 0.4)), normalize(vec2(0.3, 0.2)), normalize(vec2(0.5, 0.1))};
    const float a[wn] = {0.02, 0.01, 0.01};
    const float q[wn] = {2.7, 1.3, 4.3};
    const float p[wn] = {1.7, 5.8, 15.9};
    const float w[wn] = {5.0, 20.1, 50.0};

    vec3 n = vec3(0.0, 10.0, 0.0);
    for(int i = 0; i < wn; i++){
        float wa = w[i]*a[i];
        float cs = w[i]*dot(d[i], v.xz) + p[i]*time*WAVE_SPEED;
        float s = sin(cs);
        float c = cos(cs);

        n.x -= d[i].x*wa*c;
        n.z -= d[i].y*wa*c;
        n.y -= q[i]*wa*s;
    }
    return n;
}


float calcDepthFade(float scene_depth, float screen_depth){
	//scene_depth = scene_depth * 2.0 - 1.0;
	//scene_depth = (-(2.0*FAR*NEAR)/(FAR - NEAR)) / (scene_depth - (FAR + NEAR) / (FAR - NEAR));
	//scene_depth = scene_depth + height;

  return scene_depth;
  return clamp(exp((scene_depth - screen_depth)*BEER_LAW_FACTOR)*0.1, 0.0, 1.0);

	// application of beers law
	scene_depth = exp(-scene_depth * BEER_LAW_FACTOR);
	
	float depth_fade = (scene_depth - screen_depth) / (-0.026);
	
	depth_fade = clamp(depth_fade, -2.0, 2.0);
	return depth_fade;
}

float depthToDist(float d){
  float z = 2.0*d - 1.0;
  return 2.0*NEAR*FAR/(FAR + NEAR - z*(FAR - NEAR));
}

void main(){
  float t = time * SPEED;
  vec2 screencoord = gl_FragCoord.xy / resolution.xy;

  float screen_d = texture(depth_map, screencoord).x;
  float scene_d  = gl_FragCoord.z;

  vec4 alpha = texture(screen_map, screencoord);
  if (scene_d > screen_d) {
    out_color = alpha;

    gl_FragDepth = screen_d;
  } else {
    float n = noise(vs_in.texcoord + t*0.02);
    vec3 n1 = normalnoise(4.0*vs_in.texcoord + 0.01*t + 0.1*n);

    vec3 normal = dgwaves(vs_in.vertex);
    normal += 1.0*n1;
    

    float screen_z = depthToDist(screen_d);
    float scene_z = depthToDist(scene_d);
    float dif = screen_z - scene_z;

    float collision = texture(collider, (vec2(vs_in.vertex.x, -vs_in.vertex.z) + 1.0) / 2.0).r;
    float foam_dif = 0.0;
    if(collision < 0.08) {
        foam_dif = smoothstep(0.08, 0.0, collision);
    }
    else if (collision < 0.4) {
        foam_dif = 1.0 - smoothstep(0.0, 0.4, collision);

        normal += 0.1*vec3(
            -vec2(foam_dif*max(0.1*t*noise(vs_in.texcoord)*cos(20.0*foam_dif + (0.1*noise(vs_in.texcoord)+3.0)*t), 0.0)),
            -1);

        foam_dif = foam_dif*max(sin(20.0*foam_dif + (0.1*noise(vs_in.texcoord)+3.0)*t) - 0.3, 0.0);
        //foam_dif = max(foam_dif, 1.0 - clamp((screen_z - scene_z) / 0.001, 0.0, 1.0));
    }
    normal.z = max(normal.z, 0.1);
    normal = normalize(normal);

    float rad = exp(-dif*BEER_LAW_FACTOR);

    vec4 mat = 0.6*mix(deep_color, shallow_color, 3.0*rad + 0.1*n);
    //mat.g += 0.0*noise(vs_in.vertex.xz - t*0.12 + 0.3);
    mat.xyz += 0.01*n1;

    vec4 col = mix(mat, alpha, min(rad*0.7 + 0.08, 0.8));

    col = mix(col, foam_color, foam_dif);

    vec3 albedo = col.xyz;

    // Maybe full brdf is unnecessary? test performance
    vec3 hdr_color = brdfSchlickGGX(vs_in.position, normal, albedo, 0.0f, 0.0f, -sun_direction, sun_color, camera_position, 1.0);
    
    //hdr_color = mix(deep_color.rgb, hdr_color, 1.0 - smoothstep(15.0, 25.0, scene_z));

    out_color = vec4(hdr_color,  gl_FrontFacing ? 1.0 : 0.0);

    gl_FragDepth = scene_d;
  }
}

#endif
