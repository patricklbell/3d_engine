#begin VERTEX

layout (location = 0) in vec3 in_vertex;
layout (location = 3) in vec2 in_texcoord;

out VS_FS {
  vec3 position;
  vec2 texcoord;
  vec4 shadow_coord;
  vec3 vertex;
} vs_out;

uniform mat4 model;
uniform mat4 mvp;
uniform mat4 shadow_mvp;

#load lib/shared.gl
#load lib/water.gl

void main(){
    vec3 vertex = gwaves(in_vertex, time);
    vec4 v = vec4(vertex, 1.0);
    gl_Position = mvp * v;
    vs_out.position = (model * v).xyz;
    vs_out.shadow_coord = shadow_mvp * v;
    vs_out.vertex = vertex;
    vs_out.texcoord = in_texcoord;
}

#end

// Essentially a tesselation shader, but as geometry shader, make into tesselation which has lod for performance
//#if COMPILING_GS
//
//#define WAVE_STRENGTH vec2(0.45,  0.45)
//#define WAVE_FREQ     vec2(14.0, 14.0)
//#define WAVE_FACTOR   vec2(1.0,  2.0)
//#define TIME_FACTOR   vec2(1.1,  2.0)
//
//#define DIVISIONS     10.0
//
//layout (triangles) in;
//// Note max vertices are unique vertices given by n*(n + 2)
//layout (triangle_strip, max_vertices = 120) out;
//
//in VS_GS
//{
//  vec2 texcoord;
//} vs_in[];
//
//out GS_FS
//{
//  vec3 position;
//  vec2 texcoord;
//  vec4 shadow_coord;
//  vec3 vertex;
//} gs_out;
//
//
//uniform float time;
//uniform mat4 mvp;
//uniform mat4 shadow_mvp;
//uniform mat4 model;
//
//// https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models
//void gwaves(inout vec3 v) {
//  const int n = 1;
//  const vec2  d[] = {vec2(0.2, 0.5)};
//  const float a[] = {0.3};
//  const float q[] = {1.0};
//  const float p[] = {1.0};
//  const float w[] = {6.0};
//  for(int i = 0; i < n; i++){
//    float c1 = dot(w[i]*d[i], v.xz) + p[i]*time*0.9;
//    float c2 = q[i]*a[i];
//    v.x += c2*d[i].x * v.x*cos(c1);
//    v.z += c2*d[i].y * v.z*cos(c1);
//
//    v.y += a[i]*sin(c1);
//  }
//}
//
//void main() {
//  vec3 leg2 = gl_in[1].gl_Position.xyz - gl_in[0].gl_Position.xyz;
//  vec3 leg1 = gl_in[1].gl_Position.xyz - gl_in[2].gl_Position.xyz;
//  vec3 leg3 = gl_in[2].gl_Position.xyz - gl_in[0].gl_Position.xyz;
//  vec3 origin;
//  if(dot(leg2, leg2) > dot(leg1, leg1)){
//    leg1 = leg3;
//    origin = gl_in[0].gl_Position.xyz;
//  } else {
//    leg2 = leg3;
//    leg2 *= -1.0;
//    origin = gl_in[2].gl_Position.xyz;
//  }
//  leg1 /= DIVISIONS;
//  leg2 /= DIVISIONS;
//
//
//  vec4 v;
//  for(float x = 0.0; x < DIVISIONS; x++){
//    for(float y = 0.0; y < DIVISIONS - x; y++){
//      gs_out.vertex = origin + y*leg1 + x*leg2;
//      gwaves(gs_out.vertex);
//      v = vec4(gs_out.vertex, 1.0);
//      gl_Position = mvp * v;
//      gs_out.position = (model * v).xyz;
//      gs_out.shadow_coord = shadow_mvp * v;
//      gs_out.texcoord = vec2(y/DIVISIONS, x/DIVISIONS);
//      EmitVertex();
//      gs_out.vertex = origin + y*leg1 + (x+1.0)*leg2;
//      gwaves(gs_out.vertex);
//      v = vec4(gs_out.vertex, 1.0);
//      gl_Position = mvp * v;
//      gs_out.position = (model * v).xyz;
//      gs_out.shadow_coord = shadow_mvp * v;
//      gs_out.texcoord = vec2(y/DIVISIONS, (x+1.0)/DIVISIONS);
//      EmitVertex();
//    }
//    gs_out.vertex = origin + (DIVISIONS - x)*leg1 + x*leg2;
//    gwaves(gs_out.vertex);
//    v = vec4(gs_out.vertex, 1.0);
//    gl_Position = mvp * v;
//    gs_out.position = (model * v).xyz;
//    gs_out.shadow_coord = shadow_mvp * v;
//    gs_out.texcoord = vec2((DIVISIONS-x)/DIVISIONS, x/DIVISIONS);
//    EmitVertex();
//    EndPrimitive();
//  }
//}  
//
//#endif

#begin FRAGMENT
#macro SHADOWS 0
#macro VOLUMETRICS 1

#load lib/constants.gl
#load lib/shared.gl
#load lib/water.gl
#load lib/pbr.gl
#load lib/utilities.gl

#if VOLUMETRICS
#load lib/volumetrics.gl
#endif

#define EDGE_SCALE      1.252

#define SPEED           0.5
#define BEER_LAW_FACTOR 1.0

in VS_FS
{
    vec3 position;
    vec2 texcoord;
    vec4 shadow_coord;
    vec3 vertex;
} vs_in;

layout (depth_any) out float gl_FragDepth;
layout (location = 0) out vec4 out_color;

layout (binding = 1) uniform sampler2D depth_map;
layout (binding = 2) uniform sampler2D simplex_gradient;
layout (binding = 3) uniform sampler2D simplex_value;
layout (binding = 4) uniform sampler2D collider;

uniform vec4 shallow_color;
uniform vec4 deep_color;
uniform vec4 foam_color;

// Use pre generated noise from
// https://www.shadertoy.com/view/XdXBRH
float noise(vec2 v){
   return texture(simplex_value, v).r;
}
vec3 normalnoise(vec2 v){
   return texture(simplex_gradient, v).rgb;
}


float calcDepthFade(float scene_depth, float screen_depth){
	//scene_depth = scene_depth * 2.0 - 1.0;
	//scene_depth = (-(2.0*FAR*NEAR)/(FAR - NEAR)) / (scene_depth - (FAR + NEAR) / (FAR - NEAR));
	//scene_depth = scene_depth + height;

  return scene_depth;
  return clamp(exp((scene_depth - screen_depth)*BEER_LAW_FACTOR)*0.1, 0.0, 1.0);

	// application of beers law
	scene_depth = exp(-scene_depth * BEER_LAW_FACTOR);
	
	float depth_fade = (scene_depth - screen_depth) / (-0.026);
	
	depth_fade = clamp(depth_fade, -2.0, 2.0);
	return depth_fade;
}

void main(){
    float t = time * SPEED;
    vec2 screencoord = gl_FragCoord.xy / window_size.xy;

    float screen_d = texture(depth_map, screencoord).x;
    float scene_d  = gl_FragCoord.z;
  
    float n = noise(vs_in.texcoord + t*0.02);
    vec3 n1 = normalnoise(4.0*vs_in.texcoord + 0.01*t + 0.1*n);

    vec3 normal = dgwaves(vs_in.vertex, time);
    normal += 1.0*n1;

    float screen_z = depthToDist(screen_d);
    float scene_z = depthToDist(scene_d);
    float dif = screen_z - scene_z;

    float collision = texture(collider, (vec2(vs_in.vertex.x, -vs_in.vertex.z) + 1.0) / 2.0).r;
    float foam_dif = 0.0;
    if(collision < 0.08) {
        foam_dif = smoothstep(0.08, 0.0, collision);
    }
    else if (collision < 0.4) {
        foam_dif = 1.0 - smoothstep(0.0, 0.4, collision);

        normal += 0.1*vec3(
            -vec2(foam_dif*max(0.1*t*noise(vs_in.texcoord)*cos(20.0*foam_dif + (0.1*noise(vs_in.texcoord)+3.0)*t), 0.0)),
            -1);

        foam_dif = foam_dif*max(sin(20.0*foam_dif + (0.1*noise(vs_in.texcoord)+3.0)*t) - 0.3, 0.0);
        //foam_dif = max(foam_dif, 1.0 - clamp((screen_z - scene_z) / 0.001, 0.0, 1.0));
    }
    normal.z = max(normal.z, 0.1);
    normal = normalize(normal);

    float rad = exp(-dif*BEER_LAW_FACTOR);

    vec4 mat = mix(deep_color, shallow_color, 3.0*rad + 0.1*n);

    mat.w = mix(1.0, mat.w, rad*0.7 + 0.08);
    vec4 col = mix(mat, foam_color, foam_dif);

    // Maybe full brdf is unnecessary? test performance
    col.xyz = brdfSchlickGGX(vs_in.position, normal, col.xyz, 0.0f, 0.8f, -sun_direction, sun_color, camera_position, 1.0);
    
    //hdr_color = mix(deep_color.rgb, hdr_color, 1.0 - smoothstep(15.0, 25.0, scene_z));

#if VOLUMETRICS
    col.rgb = addInscatteredVolumetrics(col.rgb, gl_FragCoord.xyz);
#endif

    out_color = col;
}

#end